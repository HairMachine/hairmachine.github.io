<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-20T15:52:58+00:00</updated><id>http://localhost:4000/</id><title type="html">hair’s lair</title><subtitle>Games, musings, code.</subtitle><entry><title type="html">Introducing ‘Rabalais’</title><link href="http://localhost:4000/technical/rabalais/2018/03/04/introducing-rabalais.html" rel="alternate" type="text/html" title="Introducing 'Rabalais'" /><published>2018-03-04T13:49:12+00:00</published><updated>2018-03-04T13:49:12+00:00</updated><id>http://localhost:4000/technical/rabalais/2018/03/04/introducing-rabalais</id><content type="html" xml:base="http://localhost:4000/technical/rabalais/2018/03/04/introducing-rabalais.html">&lt;p&gt;Rabalais is at heart a simple DSL for specifying triggers attached to textual information, and responses to player choices 
in dialogue. It is designed to not be standalone but to work alongside other systems; a plugin for RPG Maker is already 
working, and it will obviously connect with Rosenberg in a simple fashion. Each implementation of the Rabalais language 
will interface with the provided system’s state management. It’s named after a French monk who was instrumental in
the development of the French language. My naming schemas are so great right?! One thing I’ve noticed is it’s hard to
type correctly. My fingers keep doing ‘Rabalias’.&lt;/p&gt;

&lt;p&gt;I was motivated to create Rabalais by a couple of things:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The lack of a portable dialogue engine that isn’t tied to some other huge framework, like Unity or the like&lt;/li&gt;
  &lt;li&gt;The want for a more powerful, non-tree based system specifically designed for dynamic and reactive storytelling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Specifically I was playing around with an ‘epic fantasy RPG’ in RPG maker and finding the inbuilt tools hopelessly
unfit for my purposes.&lt;/p&gt;

&lt;p&gt;The language specification is currently simple; a few operators combined into expressions to check whether a particular 
text box should trigger, reading variables and comparing them to user-provided values; if the expression evaluates as 
true, the textual payload is returned. Rabalais supports simple branching tree-structures within a single node to make 
writing simple dialogue trees bearable, has the ability to give the player a number of fixed choices (each of which can 
be made conditional on state) and can also update state variables as a result of player choices.&lt;/p&gt;

&lt;p&gt;The structure of a Rabalais is not representable as a simple two dimensional tree, as any box can connect to any other 
depending on how the game state moves. This is powerful but also will become incredibly hard to organise; to that end an 
important part of the Rabalais project is an editor that - in addition to creating nodes and controlling on which state 
they’re active - allows the designer to simulate the game state and observe which values will be available in which specific 
situations, as well as alter these state values themselves and observe which nodes become active or inactive.&lt;/p&gt;

&lt;p&gt;Rabalais is intended to become more complex and facilitate greater levels of sophistication, particularly in regards to 
procedural text generation based on state.&lt;/p&gt;</content><author><name></name></author><summary type="html">Rabalais is at heart a simple DSL for specifying triggers attached to textual information, and responses to player choices in dialogue. It is designed to not be standalone but to work alongside other systems; a plugin for RPG Maker is already working, and it will obviously connect with Rosenberg in a simple fashion. Each implementation of the Rabalais language will interface with the provided system’s state management. It’s named after a French monk who was instrumental in the development of the French language. My naming schemas are so great right?! One thing I’ve noticed is it’s hard to type correctly. My fingers keep doing ‘Rabalias’.</summary></entry><entry><title type="html">The failure of interactive storytelling</title><link href="http://localhost:4000/philosophy/2018/02/19/failure-interactive-storytelling.html" rel="alternate" type="text/html" title="The failure of interactive storytelling" /><published>2018-02-19T13:49:12+00:00</published><updated>2018-02-19T13:49:12+00:00</updated><id>http://localhost:4000/philosophy/2018/02/19/failure-interactive-storytelling</id><content type="html" xml:base="http://localhost:4000/philosophy/2018/02/19/failure-interactive-storytelling.html">&lt;p&gt;I think it’s uncontroversial to say stories are ingrained in our psyches. As animals time is one of our fundamental experiences, 
and the organisation of events into narratives of cause and effect is extremely important in our understanding of the world. 
Consequently stories have an innate attraction to us; stories allow us to imagine and experience new worlds, to challenge 
our ideas and feelings, and to gain new understanding of our lives.&lt;/p&gt;

&lt;p&gt;The idea of interactive storytelling is old, and the most pop-culture friendly examples are the entertainment programs of 
Star Trek’s holodeck. These appear to be taken as the ultimate end points of games; true works of art of full emotional 
breadth, in which you can act and react and participate within the story, which moulds itself around your actions and is 
able to create novel and exciting situations. Many, many designers have this goal in mind and attempt to achieve it, 
particularly RPG designers who focus on choice, consequence and reactivity. The link between the RPG and interactive 
storytelling is clearly strong; pen and paper RPGs use a human game master to handle their players, allowing for extremely 
rich gameplay (dependent on the skill of the game master). Can we do something approaching this with video games?&lt;/p&gt;

&lt;p&gt;The major stumbling block here is that interactive storytelling is a brutally hard problem. Most tackle it with a branching 
tree structure, but it’s easy to see these are very limited in their responsiveness and flexibility. They are almost as 
un-interactive as turning a page in a book, and indeed page-turning is how classic tree based interactive stories such 
as Fighting Fantasy or Choose Your Own Adventure functioned. Those who have tried to go further often run into serious 
problems.&lt;/p&gt;

&lt;p&gt;Chris Crawford, a veteran game designer probably most notable for “Balance of Power”, an extremely detailed simulation of 
cold-war geopolitics, has recently abandoned his attempt to solve these problems after a series of failures to produce 
working games. His work hinges around the design of autonomous AI agents which act by following personality inclinations 
and a verb-based human-computer interaction pattern, but the emergent complexity of the resultant system is enormous and 
it becomes borderline impossible to produce bug-free or enjoyable gameplay. In addition despite the complexity it also 
suffers from repetitiveness and uncanny valley issues, and the stripped-back language used to communicate between the 
player and computer is dry and technical, completely lacking dramatic flair.&lt;/p&gt;

&lt;p&gt;Another major attempt, Versu by Emily Short and Richard Evans, works on a different system - AI agents backed up by human 
writing and scene structuring. AI agents interact with each other and the player, and based on their inclinations cause 
certain scenes in the story to play out or not, as well as being provided with default responses and interactions to the 
unfolding events in the case where they are called on to behave in unanticipated ways. This creates a far richer palette 
than standard tree-based structures, and does not fall prey as badly to the explosive complexity of Crawford’s approach 
(whilst being less ambitious in scope). The main issue with Versu is in the dichotomy between its AI agents and what the 
author has provided. In the example game, Blood and Honour, it is very easy to produce strange effects from the AI, such 
as getting them to flirt with you while their partners look benignly on; the poor partner, constrained by what the author 
has imagined for their reactions, can only sit mute before spouting their next plot point. This can result in some truly 
hilarious absurdities. Versu, though a strong system with great potential, ultimately lost its funding after the release 
of one game.&lt;/p&gt;

&lt;p&gt;Generally speaking, though true interactive storytelling is a way off, there is much to be improved about the interactivity 
of stories. In particular, a relatively simple system and tools for constructing complex non-tree based narrative structures, 
which are controllable with logic and have access to underlying game state, does not exist in a portable form. Such a system 
would work by allowing human-curated narrative structure to be tied to arbitrarily complex game states, allowing designers 
more control over how they present story material.&lt;/p&gt;

&lt;p&gt;This approach, while not really true interactive storytelling, but has seen some initial success in games such as “Facade” 
and “80 days”, where a bewildering array of possibilities branch from subtle changes in underlying state, creating something 
that feels much more explorable and less easily exploitable than node based trees. Many RPGs use a similar system; 
“Planescape Torment” is often held up as a prime example of a rich, branching narrative within this framework.&lt;/p&gt;

&lt;p&gt;On the whole though, stories in games are basically linear, largely unreactive, and mostly follow simple tree structures; 
the stories are uninteractive, leaving the interactivity to be handled by other mechanics. Crawford has called this 
‘kinotropic storytelling’; by quickly switching between static story and interactive gameplay, the designer hopes to give 
the impression of an interactive story. Like the kinotrope, this is illusory.&lt;/p&gt;

&lt;p&gt;While true interactive storytelling is probably not completely possible, there is still a lot of scope to make the integration
of story and game more dynamic and interesting.&lt;/p&gt;</content><author><name></name></author><summary type="html">I think it’s uncontroversial to say stories are ingrained in our psyches. As animals time is one of our fundamental experiences, and the organisation of events into narratives of cause and effect is extremely important in our understanding of the world. Consequently stories have an innate attraction to us; stories allow us to imagine and experience new worlds, to challenge our ideas and feelings, and to gain new understanding of our lives.</summary></entry><entry><title type="html">Introducing ‘Rosenberg’</title><link href="http://localhost:4000/technical/rosenberg/2018/02/09/introducing-rosenberg.html" rel="alternate" type="text/html" title="Introducing 'Rosenberg'" /><published>2018-02-09T13:49:12+00:00</published><updated>2018-02-09T13:49:12+00:00</updated><id>http://localhost:4000/technical/rosenberg/2018/02/09/introducing-rosenberg</id><content type="html" xml:base="http://localhost:4000/technical/rosenberg/2018/02/09/introducing-rosenberg.html">&lt;p&gt;‘Rosenberg’ is the code name for a game design framework and engine I’m currently working onthat tries to move focus away 
from programming technical tasks, and programming game rules. The name is after board game designer Uwe Rosenberg 
(Agricola, Caverna etc.).&lt;/p&gt;

&lt;p&gt;The main inspiration for Rosenberg is basically two-fold:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I find most existing prototyping techniques slow and annoying&lt;/li&gt;
  &lt;li&gt;The lack of high-level beginner systems that emphasize design of game rulesets in the abstract sense&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rosenberg attempts to do for strategy game design what RPG Maker has done for RPG creation - create a simple tool which 
entirely focuses its design on mechanical rules and handles all the technical problems itself. As such it is takes the 
form of a game engine with a custom DSL for writing game mechanics within a turn-based structure; mechanical effects are 
then updated onto the screen. Rather than defining objects and classes as programming primitives, authors work directly 
with Components, each of which has a visible manifestation on the screen, Resources, which track internal values, and 
Rules, which act on resources and components in order to mutate the game state. Components can be placed onto ‘Boards’, 
each of which takes up a section of the screen, and ‘Screens’ which can be layered on top of the other, opened and closed. 
The game designer should be thinking only on the highest level, about how components interact with the player and with 
each other.&lt;/p&gt;

&lt;p&gt;Rosenberg’s DSL is a declarative language which borrows design elements from state management containers such as Vuex, 
Redux or Elm. Events are dispatched from the engine, and the given rules listen and, if they should trigger, relay their 
instructions to the engine, which then implements them and updates the graphical representation accordingly. The language 
is intended to be as close to data as possible; the plan is to provide a form-based editor for tweaking and creating 
parameters, with mutators provided that allow various types of generic state transformation commonly needed in games. 
Custom mutators will be possible to create for more technical users; currently these are done by compiling in custom C 
functions using a provided builder, but there is planned a Lua scripting option too for faster iteration. Plugins will be 
creatable that provide suites of custom functions to provide more sophisticated functionality that can then be shared in a 
community.&lt;/p&gt;

&lt;p&gt;The primary usefulness of Rosenberg will probably be in rapid game prototyping, but the plan is to allow users to release 
their games as full products as well if they desire. The engine will come with a large array of pre-created tokens and 
graphics for players to use, which are easily swappable for custom art by specifying configuration.&lt;/p&gt;

&lt;p&gt;Technically speaking this is fairly early in development. It’s written in C using SDL as the graphics library. Hopefully
more as it progresses! The language itself is capable of handling most of the rules of chess correctly (with the exception
of castling and en passant, both of which require more sophisticated state management). I’m excited about this project
and hope it’ll at least be useful for me in my prototyping.&lt;/p&gt;</content><author><name></name></author><summary type="html">‘Rosenberg’ is the code name for a game design framework and engine I’m currently working onthat tries to move focus away from programming technical tasks, and programming game rules. The name is after board game designer Uwe Rosenberg (Agricola, Caverna etc.).</summary></entry><entry><title type="html">The conflation of design and development</title><link href="http://localhost:4000/philosophy/2018/02/05/conflation-of-design-development.html" rel="alternate" type="text/html" title="The conflation of design and development" /><published>2018-02-05T13:49:12+00:00</published><updated>2018-02-05T13:49:12+00:00</updated><id>http://localhost:4000/philosophy/2018/02/05/conflation-of-design-development</id><content type="html" xml:base="http://localhost:4000/philosophy/2018/02/05/conflation-of-design-development.html">&lt;p&gt;I think one thing holding back video game design is something inherent to its ontology. This is the fact that design
and development are often conflated, both in tooling and in how work is approached. The reason for this is pretty simple. 
In order to make a video game, you must have programmer. Video games run on computers, and the computers need to be 
instructed by writing code. This has a corollary: in order to be a solo game developer you must be a programmer.&lt;/p&gt;

&lt;p&gt;This leads to problems immediately. Not all artists are programmers; many great video game designers may simply never 
be able to express their ideas due to a lack of technical knowledge or ability. To solve this, there are engines which 
try to reduce the burden of programming. The most successful of these at reducing the burden go hand in hand with 
aggressively restricted mechanical control for the user - they restrict far too much. Examples of these are RPG Maker 
and Adventure Game Studio. More general game development frameworks designed for beginners, such as Game Maker, provide 
paradigms that simplify development by strongly pushing mechanical expression into physically simulated interactions 
between objects - collisions, forces, movement - and reflex-based gameplay.&lt;/p&gt;

&lt;p&gt;Ultimately, game design should be seen as a formal discipline requiring logical and mathematical reasoning as well as 
artistic intent, so any prospective designer will need to be able to think in these terms. No system currently encourages 
this or provides good tooling to develop these skills.&lt;/p&gt;

&lt;p&gt;Worse than this, in my opinion, is the conflation of design and development. This is the casting of all game design 
problems as technical challenges; changes to rulesets are often seen as being on the same level as programming a UI, building 
map systems, dialogue systems, and other non-rule subsystems. Game programmers thus spend a disproportionate amount 
of time on technical challenges. Unfortunately, it is far easier to solve technical challenges when you know exactly what 
you are doing, so tried and true mechanics and approaches are guaranteed to be more popular. Making mechanical changes, 
unless the code has been specifically designed to be prototyping friendly, can become entangled with technical or even 
architectural changes that discourage experimentation lest the project spontaneously collapse under its own entropy. 
This is an experience all too common to the budding amateur game designer.&lt;/p&gt;

&lt;p&gt;I believe design questions should be seen as primarily artistic questions, not primarily technical questions, and should 
be isolated from each other as much as possible. Changing game rules should not require changing game architecture, and 
vice versa.&lt;/p&gt;</content><author><name></name></author><summary type="html">I think one thing holding back video game design is something inherent to its ontology. This is the fact that design and development are often conflated, both in tooling and in how work is approached. The reason for this is pretty simple. In order to make a video game, you must have programmer. Video games run on computers, and the computers need to be instructed by writing code. This has a corollary: in order to be a solo game developer you must be a programmer.</summary></entry><entry><title type="html">Manifesto: game mechanics as art</title><link href="http://localhost:4000/philosophy/2018/01/29/mechanics-as-art.html" rel="alternate" type="text/html" title="Manifesto: game mechanics as art" /><published>2018-01-29T13:49:12+00:00</published><updated>2018-01-29T13:49:12+00:00</updated><id>http://localhost:4000/philosophy/2018/01/29/mechanics-as-art</id><content type="html" xml:base="http://localhost:4000/philosophy/2018/01/29/mechanics-as-art.html">&lt;p&gt;Art is primarily a form of self-expression. Through a given medium, the artist creates a situation or world view which has 
some emotional resonance with the viewer, and invites them to experience this work. Through viewing the work, the viewer 
comes to understand or see something from a fresh perspective, a process which is extremely important to us all.&lt;/p&gt;

&lt;p&gt;Game mechanics are largely not viewed as art. This is because at this point mechanisms in games lack the requisite 
expressiveness; in computer games, they mostly revolve around world simulation, particularly modelling combat (but also 
modelling other real world physical things and economic simulation). Combat is easy to model because the physics and 
dynamics of movement, shooting, damage etc. are well known and ready abstractions for these things are accessible and 
simple to understand. So ingrained is this mindset that most game prototypes start with a guy moving around the map 
shooting. As game designer Tom Francis has put it, “shooting, therefore videogames”.&lt;/p&gt;

&lt;p&gt;This narrowness harms game mechanics as a medium of artistic expression. The human experience is not limited to war and 
combat, and there is much else to say which games at the moment struggle to express in their own terms. In order to 
express these deeper artistic intentions, games borrow heavily from the techniques of literature, cinema and music to 
infuse their rudimentary self-expression with greater nuance and depth. Game designers strive to express more profound 
emotions and to connect with their audiences, but their abilities to design systems that reinforce these points are 
often lacking.&lt;/p&gt;

&lt;p&gt;This commonly results in what is known as ‘ludonarrative dissonance’ - mechanics running counter to what the game tries 
to say. A famous example of this is in the 2013 reboot of Tomb Raider. During its cinematic segments the game portrays
a story about an inexperienced young woman trapped in a desperate and terrible situation, and struggling with its 
traumatic effects. In the gameplay segments, she suddenly turns into a battle-hardened terminator blasting down hundreds 
of faceless bad guys. Similar problems affect games such as the “Uncharted” series, whose hero Nathan Drake is portrayed in cinematic scenes as a dashing and heroic treasure hunter, and in gameplay a psychopathic mass murderer, making witty comments while casually slaughtering thousands of people whose only crime was apparently to be in the way of his loot.&lt;/p&gt;

&lt;p&gt;Games usually get around this by portraying their world as fundamentally warped, distorted, hostile or inhuman, or by 
embracing the psychopathy of the protagonist. “Bioshock” and “The Last of Us” are strong examples of the former, and 
the “Grand Theft Auto” series leans towards the latter (with arguable success).&lt;/p&gt;

&lt;p&gt;Another way is to make fewer games about shooting, but this is hard without having the language to express more subtle 
things mechanically.&lt;/p&gt;

&lt;p&gt;There is no inherent reason why game mechanics cannot support their narrative in powerful and creative ways, and no 
reason why system design cannot itself become an art form where the choice of how to build the interactive components 
is an integral part of the artist’s self expression. There are already games that do this: three examples are “Undertale”, 
“This War of Mine” and “Passage”. These games all received universal acclaim due to the strong emotional effect they 
produced on the player. By utilising mechanics as a fundamental part of the expression, rather than being an emotionless 
video game with an emotional story attached to it, the overall effect of the work was dramatically increased.&lt;/p&gt;

&lt;p&gt;My thesis: we want more of this, and the best way to do it is to focus on mechanical innovation and increasing our
understanding of how we can build systems with emotional resonance.&lt;/p&gt;</content><author><name></name></author><summary type="html">Art is primarily a form of self-expression. Through a given medium, the artist creates a situation or world view which has some emotional resonance with the viewer, and invites them to experience this work. Through viewing the work, the viewer comes to understand or see something from a fresh perspective, a process which is extremely important to us all.</summary></entry></feed>